# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from collections import defaultdict

import pretend

from celery.schedules import crontab

from warehouse import malware
from warehouse.malware.interfaces import IMalwareCheckService
from warehouse.malware.tasks import run_scheduled_check

from ...common import checks as test_checks
from ...common.db.accounts import UserFactory
from ...common.db.packaging import FileFactory, ProjectFactory, ReleaseFactory


def test_determine_malware_checks_no_checks(monkeypatch, db_request):
    def get_enabled_hooked_checks(session):
        return defaultdict(list)

    monkeypatch.setattr(malware, "get_enabled_hooked_checks", get_enabled_hooked_checks)

    project = ProjectFactory.create(name="foo")
    release = ReleaseFactory.create(project=project)
    file0 = FileFactory.create(release=release, filename="foo.bar")

    session = pretend.stub(info={}, new={file0, release, project}, dirty={}, deleted={})

    malware.determine_malware_checks(pretend.stub(), session, pretend.stub())
    assert session.info["warehouse.malware.checks"] == set()


def test_determine_malware_checks_nothing_new(monkeypatch, db_request):
    def get_enabled_hooked_checks(session):
        result = defaultdict(list)
        result["File"] = ["Check1", "Check2"]
        result["Release"] = ["Check3"]
        return result

    monkeypatch.setattr(malware, "get_enabled_hooked_checks", get_enabled_hooked_checks)

    project = ProjectFactory.create(name="foo")
    release = ReleaseFactory.create(project=project)
    file0 = FileFactory.create(release=release, filename="foo.bar")

    session = pretend.stub(info={}, new={}, dirty={file0, release}, deleted={})

    malware.determine_malware_checks(pretend.stub(), session, pretend.stub())
    assert session.info.get("warehouse.malware.checks") is None


def test_determine_malware_checks_unsupported_object(monkeypatch, db_request):
    def get_enabled_hooked_checks(session):
        result = defaultdict(list)
        result["File"] = ["Check1", "Check2"]
        result["Release"] = ["Check3"]
        return result

    monkeypatch.setattr(malware, "get_enabled_hooked_checks", get_enabled_hooked_checks)

    user = UserFactory.create()

    session = pretend.stub(info={}, new={user}, dirty={}, deleted={})

    malware.determine_malware_checks(pretend.stub(), session, pretend.stub())
    assert session.info.get("warehouse.malware.checks") is None


def test_determine_malware_checks_file_only(monkeypatch, db_request):
    def get_enabled_hooked_checks(session):
        result = defaultdict(list)
        result["File"] = ["Check1", "Check2"]
        result["Release"] = ["Check3"]
        return result

    monkeypatch.setattr(malware, "get_enabled_hooked_checks", get_enabled_hooked_checks)

    project = ProjectFactory.create(name="foo")
    release = ReleaseFactory.create(project=project)
    file0 = FileFactory.create(release=release, filename="foo.bar")

    session = pretend.stub(info={}, new={file0}, dirty={}, deleted={})

    checks = set(["Check%d:%s" % (x, file0.id) for x in range(1, 3)])
    malware.determine_malware_checks(pretend.stub(), session, pretend.stub())
    assert session.info["warehouse.malware.checks"] == checks


def test_determine_malware_checks_file_and_release(monkeypatch, db_request):
    def get_enabled_hooked_checks(session):
        result = defaultdict(list)
        result["File"] = ["Check1", "Check2"]
        result["Release"] = ["Check3"]
        return result

    monkeypatch.setattr(malware, "get_enabled_hooked_checks", get_enabled_hooked_checks)

    project = ProjectFactory.create(name="foo")
    release = ReleaseFactory.create(project=project)
    file0 = FileFactory.create(release=release, filename="foo.bar")
    file1 = FileFactory.create(release=release, filename="foo.baz")

    session = pretend.stub(
        info={}, new={project, release, file0, file1}, dirty={}, deleted={}
    )

    checks = set(["Check%d:%s" % (x, file0.id) for x in range(1, 3)])
    checks.update(["Check%d:%s" % (x, file1.id) for x in range(1, 3)])
    checks.add("Check3:%s" % release.id)

    malware.determine_malware_checks(pretend.stub(), session, pretend.stub())

    assert session.info["warehouse.malware.checks"] == checks


def test_enqueue_malware_checks(app_config):
    malware_check = pretend.stub(
        run_checks=pretend.call_recorder(lambda malware_checks: None)
    )
    factory = pretend.call_recorder(lambda ctx, config: malware_check)
    app_config.register_service_factory(factory, IMalwareCheckService)
    app_config.commit()
    session = pretend.stub(
        info={
            "warehouse.malware.checks": {"Check1:ba70267f-fabf-496f-9ac2-d237a983b187"}
        }
    )

    malware.queue_malware_checks(app_config, session)

    assert factory.calls == [pretend.call(None, app_config)]
    assert malware_check.run_checks.calls == [
        pretend.call({"Check1:ba70267f-fabf-496f-9ac2-d237a983b187"})
    ]
    assert "warehouse.malware.checks" not in session.info


def test_enqueue_malware_checks_no_checks(app_config):
    session = pretend.stub(info={})
    malware.queue_malware_checks(app_config, session)
    assert "warehouse.malware.checks" not in session.info


def test_includeme(monkeypatch):
    monkeypatch.setattr(malware, "checks", test_checks)

    malware_check_class = pretend.stub(
        create_service=pretend.call_recorder(lambda *a, **kw: pretend.stub())
    )

    config = pretend.stub(
        maybe_dotted=lambda dotted: malware_check_class,
        register_service_factory=pretend.call_recorder(
            lambda factory, iface, name=None: None
        ),
        registry=pretend.stub(
            settings={"malware_check.backend": "TestMalwareCheckService"}
        ),
        add_periodic_task=pretend.call_recorder(lambda *a, **kw: None),
    )

    malware.includeme(config)

    assert config.register_service_factory.calls == [
        pretend.call(malware_check_class.create_service, IMalwareCheckService)
    ]

    assert config.add_periodic_task.calls == [
        pretend.call(
            crontab(minute="0", hour="*/8"),
            run_scheduled_check,
            args=("ExampleScheduledCheck",),
        )
    ]
