# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import inspect

import warehouse.malware.checks as checks
import warehouse.packaging.models as packaging_models

from warehouse.malware.models import MalwareCheck, MalwareCheckState, MalwareVerdict
from warehouse.malware.utils import get_check_fields
from warehouse.tasks import task


@task(bind=True, ignore_result=True, acks_late=True, retry_backoff=True)
def run_check(task, request, check_name, obj_id):
    check = getattr(checks, check_name)(request.db)
    try:
        kwargs = check.prepare(request, obj_id)
        check.run(obj_id=obj_id, **kwargs)
    except Exception as exc:
        request.log.error("Error executing check %s: %s" % (check_name, str(exc)))
        raise task.retry(exc=exc)


@task(bind=True, ignore_result=True, acks_late=True)
def backfill(task, request, check_name, num_objects):
    """
    Runs a backfill on a fixed number of objects.
    """
    check = getattr(checks, check_name)(request.db)
    target_object = getattr(packaging_models, check.hooked_object)
    query = request.db.query(target_object.id).limit(num_objects)

    request.log.info("Running backfill on %d %ss." % (num_objects, check.hooked_object))

    for (elem_id,) in query:
        request.task(run_check).delay(check_name, elem_id)


@task(bind=True, ignore_result=True, acks_late=True)
def sync_checks(task, request):
    code_checks = inspect.getmembers(checks, inspect.isclass)
    request.log.info("%d malware checks found in codebase." % len(code_checks))

    all_checks = request.db.query(MalwareCheck).all()
    active_checks = {}
    wiped_out_checks = {}
    for check in all_checks:
        if not check.is_stale:
            if check.state == MalwareCheckState.WipedOut:
                wiped_out_checks[check.name] = check
            else:
                active_checks[check.name] = check

    if len(active_checks) > len(code_checks):
        code_check_names = set([name for name, cls in code_checks])
        missing = ", ".join(set(active_checks.keys()) - code_check_names)
        request.log.error(
            "Found %d active checks in the db, but only %d checks in \
code. Please manually move superfluous checks to the wiped_out state \
in the check admin: %s"
            % (len(active_checks), len(code_checks), missing)
        )
        raise Exception("Mismatch between number of db checks and code checks.")

    for check_name, check_class in code_checks:
        check = getattr(checks, check_name)

        if wiped_out_checks.get(check_name):
            request.log.error(
                "%s is wiped_out and cannot be synced. Please remove check from \
codebase."
                % check_name
            )
            continue

        db_check = active_checks.get(check_name)
        if db_check:
            if check.version == db_check.version:
                request.log.info("%s is unmodified." % check_name)
                continue

            request.log.info("Updating existing %s." % check_name)
            fields = get_check_fields(check)

            # Migrate the check state to the newest check.
            # Then mark the old check state as disabled.
            if db_check.state != MalwareCheckState.Disabled:
                fields["state"] = db_check.state.value
                db_check.state = MalwareCheckState.Disabled

            request.db.add(MalwareCheck(**fields))
        else:
            request.log.info("Adding new %s to the database." % check_name)
            fields = get_check_fields(check)
            request.db.add(MalwareCheck(**fields))


@task(bind=True, ignore_result=True, acks_late=True)
def remove_verdicts(task, request, check_name):
    check_ids = (
        request.db.query(MalwareCheck.id, MalwareCheck.version)
        .filter(MalwareCheck.name == check_name)
        .all()
    )
    total_deleted = 0
    for check_id, check_version in check_ids:
        query = request.db.query(MalwareVerdict).filter(
            MalwareVerdict.check_id == check_id
        )
        num_verdicts = query.count()
        request.log.info(
            "Removing %d malware verdicts associated with %s version %d."
            % (num_verdicts, check_name, check_version)
        )
        total_deleted += query.delete(synchronize_session=False)

    # This returned value is only relevant for testing.
    return total_deleted
