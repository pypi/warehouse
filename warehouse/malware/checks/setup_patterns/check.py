# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os
import tarfile
import zipfile

from io import BytesIO
from textwrap import dedent

import requests
import yara

from warehouse.malware.checks.base import MalwareCheckBase
from warehouse.malware.models import VerdictClassification, VerdictConfidence
from warehouse.packaging.models import File


class SetupPatternCheck(MalwareCheckBase):
    _yara_rule_file = os.path.join(
        os.path.dirname(os.path.abspath(__file__)), "setup_py_rules.yara"
    )

    version = 1
    short_description = "A check for common malicious patterns in setup.py"
    long_description = dedent(
        """
        This check uses YARA to search for common malicious patterns in the setup.py
        files of uploaded release archives.
        """
    )
    check_type = "event_hook"
    hooked_object = "File"

    def __init__(self, db):
        super().__init__(db)
        self._yara_rules = self._load_yara_rules()

    def _load_yara_rules(self):
        return yara.compile(filepath=self._yara_rule_file)

    def _extract_setup_contents(self, archive_stream):
        if zipfile.is_zipfile(archive_stream):
            with zipfile.ZipFile(archive_stream) as zipobj:
                for name in zipobj.namelist():
                    parts = os.path.split(name)
                    if len(parts) == 2 and parts[1] == "setup.py":
                        return zipobj.read(name)
                return None
        else:
            # NOTE: is_zipfile doesn't rewind the fileobj it's given.
            archive_stream.seek(0)

            # NOTE: We don't need to perform a sanity check on
            # the (presumed) tarfile's compression here, since we're
            # extracting from a stream that's already gone through
            # upload validation.
            # See _is_valid_dist_file in forklift/legacy.py.
            try:
                with tarfile.open(fileobj=archive_stream) as tarobj:
                    member = tarobj.next()
                    while member:
                        parts = os.path.split(member.name)
                        if len(parts) == 2 and parts[1] == "setup.py":
                            return tarobj.extractfile(member).read()
                        member = tarobj.next()
                    return None
            except tarfile.TarError:
                return None

    def scan(self, **kwargs):
        file_id = kwargs.get("obj_id")
        file_url = kwargs.get("file_url")
        if file_id is None or file_url is None:
            return

        file = self.db.query(File).filter(File.id == file_id).one()
        if file.packagetype != "sdist":
            # Per PEP 491: bdists do not contain setup.py.
            # This check only scans dists that contain setup.py, so
            # we have nothing to perform.
            return

        # TODO(ww): Handle connection errors, timeouts?
        # The check harness will catch everything eventually,
        # so these might not be worth handling explicitly.
        file_request = requests.get(file_url)
        if not file_request.ok:
            # TODO: Indeterminate verdict here?
            return

        setup_py_contents = self._extract_setup_contents(BytesIO(file_request.content))
        if setup_py_contents is None:
            self.add_verdict(
                file_id=file_id,
                classification=VerdictClassification.indeterminate,
                confidence=VerdictConfidence.High,
                message="sdist does not contain a suitable setup.py for analysis",
            )
            return

        self.add_verdict(
            file_id=file_id,
            classification=VerdictClassification.benign,
            confidence=VerdictConfidence.Medium,
            message=f"I was asked to scan {setup_py_contents}!",
        )
